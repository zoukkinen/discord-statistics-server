.PHONY: help build up down logs restart status clean dev dev-build dev-logs dev-detached prod backup restore platform-info shell shell-root heroku-validate heroku-backup heroku-restore sync-production list-backups rebuild

# Detect platform for better compatibility
UNAME_S := $(shell uname -s)
UNAME_M := $(shell uname -m)

# WSL detection
WSL_DETECTED := $(shell if [ -f /proc/version ] && grep -qi microsoft /proc/version; then echo "true"; else echo "false"; fi)

# Determine compose files based on platform
COMPOSE_FILES := -f docker-compose.yml

# Add platform-specific overrides (only for special cases)
ifeq ($(WSL_DETECTED),true)
	COMPOSE_FILES += -f docker-compose.wsl.yml
else ifeq ($(UNAME_M),arm64)
	COMPOSE_FILES += -f docker-compose.arm64.yml
endif
# Note: Linux AMD64 is the default - no override needed

# Docker compose command with platform files
DOCKER_COMPOSE := docker-compose $(COMPOSE_FILES)

# Default target
help: ## Show this help message
	@echo "Universal Discord Activity Tracker (Container-First)"
	@echo "=================================================="
	@echo ""
	@$(MAKE) platform-info
	@echo ""
	@echo "Available commands:"
	@awk 'BEGIN {FS = ":.*?## "} /^[a-zA-Z_-]+:.*?## / {printf "  \033[36m%-15s\033[0m %s\n", $$1, $$2}' $(MAKEFILE_LIST)

platform-info: ## Show platform information
	@echo "Platform Information:"
	@echo "  OS: $(UNAME_S)"
	@echo "  Architecture: $(UNAME_M)"
	@echo "  WSL Detected: $(WSL_DETECTED)"
	@echo "  Compose Files: $(COMPOSE_FILES)"
ifeq ($(WSL_DETECTED),true)
	@echo "  üêß Running on Windows Subsystem for Linux"
else ifeq ($(UNAME_M),arm64)
	@echo "  üçé ARM64 detected (Apple Silicon compatible)"
else
	@echo "  üêß Standard Linux/AMD64 (using defaults)"
endif

# Development commands
dev: ## Start fast development environment with hot reload (no rebuild needed)
	@echo "‚ö° Starting fast development environment with hot reload..."
	@if [ ! -f .env ]; then echo "‚ùå .env file not found! Copy .env.example and configure it."; exit 1; fi
	@if [ "$$(grep '^NODE_ENV=' .env | cut -d'=' -f2)" != "development" ]; then \
		echo "‚ö†Ô∏è  Warning: NODE_ENV is not set to 'development' in .env file"; \
		echo "   Current value: $$(grep '^NODE_ENV=' .env | cut -d'=' -f2)"; \
		echo "   Fast development works best with NODE_ENV=development"; \
	fi
	$(DOCKER_COMPOSE) up -d

dev-build: ## Build and start development environment (first time only)
	@echo "üî® Building development environment (first time)..."
	@if [ ! -f .env ]; then echo "‚ùå .env file not found! Copy .env.example and configure it."; exit 1; fi
	$(DOCKER_COMPOSE) up --build -d

dev-logs: ## Show logs from development environment
	@echo "üìã Showing development logs (Ctrl+C to exit)..."
	$(DOCKER_COMPOSE) logs -f discord-bot

# Production commands
prod: down ## Start in production mode (with nginx)
	@echo "üöÄ Starting Assembly Discord Tracker in production mode..."
	@if [ ! -f .env ]; then echo "‚ùå .env file not found! Copy .env.example and configure it."; exit 1; fi
	NODE_ENV=production $(DOCKER_COMPOSE) --profile production up --build -d

# Basic Docker operations
build: ## Build the Docker image
	@echo "üî® Building Discord tracker image..."
	$(DOCKER_COMPOSE) build

build-fast: ## Fast build with cache and single platform
	@echo "‚ö° Fast building for current platform only..."
	$(DOCKER_COMPOSE) build --parallel

rebuild: ## Force rebuild from scratch (no cache) and restart
	@echo "üî® Force rebuilding from scratch..."
	$(DOCKER_COMPOSE) down
	$(DOCKER_COMPOSE) build --no-cache --parallel
	$(DOCKER_COMPOSE) up -d
	@echo "‚úÖ Application rebuilt and restarted"

# Local Development (Container-First)
dev-detached: ## Start development environment in background (same as dev but silent)
	@echo "üê≥ Starting development environment in background..."
	@if [ ! -f .env ]; then echo "‚ùå .env file not found! Copy .env.example and configure it."; exit 1; fi
	@if [ "$$(grep '^NODE_ENV=' .env | cut -d'=' -f2)" != "development" ]; then \
		echo "‚ö†Ô∏è  Warning: NODE_ENV is not set to 'development' in .env file"; \
		echo "   Current value: $$(grep '^NODE_ENV=' .env | cut -d'=' -f2)"; \
		echo "   Fast development works best with NODE_ENV=development"; \
	fi
	$(DOCKER_COMPOSE) up -d

up: ## Start the services
	@echo "‚¨ÜÔ∏è  Starting services..."
	$(DOCKER_COMPOSE) up -d

down: ## Stop and remove all services
	@echo "‚¨áÔ∏è  Stopping services..."
	$(DOCKER_COMPOSE) down

restart: ## Restart all services
	@echo "üîÑ Restarting services..."
	$(DOCKER_COMPOSE) restart

# Monitoring and logs
logs: ## Show logs from all services
	$(DOCKER_COMPOSE) logs -f

logs-bot: ## Show logs from Discord bot only
	$(DOCKER_COMPOSE) logs -f discord-bot

logs-nginx: ## Show logs from nginx only (production mode)
	$(DOCKER_COMPOSE) logs -f nginx

status: ## Show status of all services
	@echo "üìä Service Status:"
	@echo "=================="
	$(DOCKER_COMPOSE) ps

health: ## Check health of the application
	@echo "üè• Health Check:"
	@echo "==============="
ifeq ($(WSL_DETECTED),true)
	@curl -s http://localhost:3000/api/health 2>/dev/null | python3 -m json.tool 2>/dev/null || curl -s http://localhost:3000/api/health 2>/dev/null || echo "‚ùå Health check failed - is the service running?"
else
	@curl -s http://localhost:3000/api/health | jq . 2>/dev/null || curl -s http://localhost:3000/api/health || echo "‚ùå Health check failed - is the service running?"
endif

# Maintenance commands
clean: ## Remove all containers, images, and volumes (DESTRUCTIVE!)
	@echo "üßπ Cleaning up Docker resources..."
	@read -p "This will remove ALL containers, images, and data. Are you sure? (y/N): " confirm && [ "$$confirm" = "y" ]
	$(DOCKER_COMPOSE) down -v --rmi all
	docker system prune -af

clean-soft: ## Remove containers and networks only (keeps data volume)
	@echo "üßπ Soft cleanup (keeping data)..."
	$(DOCKER_COMPOSE) down
	$(DOCKER_COMPOSE) rm -f

# Database operations
backup: ## Backup the local PostgreSQL database
	@echo "üíæ Creating local database backup..."
	@mkdir -p backups
	$(DOCKER_COMPOSE) exec -T postgres pg_dump -U discord_bot -d discord_stats > backups/local_backup_$(shell date +%Y%m%d_%H%M%S).sql
	@echo "‚úÖ Local backup created in backups/ directory"

restore: ## Restore database from backup (specify BACKUP_FILE=filename)
	@echo "üì• Restoring database from backup..."
	@if [ -z "$(BACKUP_FILE)" ]; then echo "‚ùå Please specify BACKUP_FILE=filename"; exit 1; fi
	@if [ ! -f "backups/$(BACKUP_FILE)" ]; then echo "‚ùå Backup file not found!"; exit 1; fi
	@echo "‚èπÔ∏è  Stopping backend to release database connections..."
	$(DOCKER_COMPOSE) stop discord-bot
	@echo "üóëÔ∏è  Preparing database for restore..."
	$(DOCKER_COMPOSE) exec -T postgres psql -U discord_bot -d postgres -c "DROP DATABASE IF EXISTS discord_stats;"
	$(DOCKER_COMPOSE) exec -T postgres psql -U discord_bot -d postgres -c "CREATE DATABASE discord_stats;"
	@echo "üì• Restoring from $(BACKUP_FILE)..."
	$(DOCKER_COMPOSE) exec -T postgres psql -U discord_bot -d discord_stats < backups/$(BACKUP_FILE)
	@echo "üîÑ Restarting backend..."
	$(DOCKER_COMPOSE) start discord-bot
	@echo "‚úÖ Database restored from $(BACKUP_FILE)"

# Heroku Production Database Operations
heroku-backup: ## Download latest backup from Heroku production
	@echo "‚òÅÔ∏è  Getting latest backup from Heroku production..."
	@if [ -z "$(HEROKU_APP)" ]; then \
		echo "‚ùå Please specify HEROKU_APP=your-app-name or set it in .env"; \
		echo "üí° Example: make heroku-backup HEROKU_APP=assembly-discord-tracker-2025"; \
		exit 1; \
	fi
	@./scripts/heroku-backup.sh backup $(HEROKU_APP)

heroku-restore: ## Restore Heroku backup to local database
	@if [ -z "$(HEROKU_APP)" ]; then \
		echo "‚ùå Please specify HEROKU_APP=your-app-name"; \
		echo "üí° Example: make heroku-restore HEROKU_APP=assembly-discord-tracker-2025"; \
		exit 1; \
	fi; \
	@echo "üîÑ Restoring Heroku backup to local development..."; \
	echo "üõë Stopping backend service to release database connections..."; \
	$(DOCKER_COMPOSE) stop discord-bot || true; \
	./scripts/heroku-backup.sh restore $(HEROKU_APP)

sync-production: ## Download and restore latest production data (one command)
	@echo "üöÄ Syncing local development with production data..."
	@if [ -z "$(HEROKU_APP)" ]; then \
		HEROKU_APP="assembly-discord-tracker-2025"; \
	fi; \
	echo "üîß Using Heroku app: $$HEROKU_APP"; \
	echo "üõë Step 1: Stopping backend service..."; \
	$(DOCKER_COMPOSE) stop discord-bot; \
	echo "‚òÅÔ∏è  Step 2: Downloading latest backup from production..."; \
	./scripts/heroku-backup.sh backup $$HEROKU_APP; \
	echo "üîÑ Step 3: Restoring to local development..."; \
	./scripts/heroku-backup.sh restore $$HEROKU_APP; \
	echo "üöÄ Step 4: Starting all development services..."; \
	$(DOCKER_COMPOSE) up -d; \
	echo "‚úÖ Local development now synced with production data!"

list-backups: ## List available database backups
	@echo "üìã Available backups:"
	@ls -la backups/ 2>/dev/null || echo "No backups found"

# Configuration helpers
setup: ## Setup environment file from example
	@if [ -f .env ]; then echo "‚ö†Ô∏è  .env already exists"; exit 1; fi
	cp .env.example .env
	@echo "‚úÖ .env file created from .env.example"
	@echo "üìù Please edit .env file with your Discord bot token and server ID"

validate-env: ## Validate environment configuration
	@echo "üîç Validating environment configuration..."
	@if [ ! -f .env ]; then echo "‚ùå .env file not found!"; exit 1; fi
	@grep -q "^DISCORD_TOKEN=" .env || (echo "‚ùå DISCORD_TOKEN not set"; exit 1)
	@grep -q "^DISCORD_GUILD_ID=" .env || (echo "‚ùå DISCORD_GUILD_ID not set"; exit 1)
	@if grep -q "your_discord_bot_token_here" .env; then echo "‚ùå Please set your actual Discord bot token"; exit 1; fi
	@if grep -q "your_discord_server_id_here" .env; then echo "‚ùå Please set your actual Discord server ID"; exit 1; fi
	@echo "‚úÖ Environment configuration looks good"

# Development helpers
shell: ## Open shell in the Discord bot container
	$(DOCKER_COMPOSE) exec discord-bot sh

shell-root: ## Open root shell in the Discord bot container
	$(DOCKER_COMPOSE) exec -u root discord-bot sh

shell-db: ## Open shell in the PostgreSQL container
	$(DOCKER_COMPOSE) exec postgres sh

shell-db-root: ## Open root shell in the PostgreSQL container
	$(DOCKER_COMPOSE) exec -u root postgres sh

update: ## Update and rebuild the application
	@echo "üîÑ Updating application..."
	git pull
	$(DOCKER_COMPOSE) down
	$(DOCKER_COMPOSE) build --no-cache
	$(DOCKER_COMPOSE) up -d
	@echo "‚úÖ Application updated and restarted"

# Quick start
quick-start: setup validate-env dev ## Complete setup and start in development mode

# Production deployment
deploy: validate-env build prod ## Deploy to production
	@echo "üéâ Discord Activity Tracker deployed successfully!"
	@echo "üåê Dashboard available at: http://localhost"
	@echo "üìä Health check: make health"

# SSL/Certificate management
ssl-init: ## Initialize SSL certificates (requires DOMAIN and EMAIL environment variables)
	@echo "üîê Initializing SSL certificates..."
	@if [ -z "$(DOMAIN)" ]; then echo "‚ùå Please specify DOMAIN=your-domain.com"; exit 1; fi
	@if [ -z "$(EMAIL)" ]; then echo "‚ùå Please specify EMAIL=your-email@example.com"; exit 1; fi
	@echo "Domain: $(DOMAIN)"
	@echo "Email: $(EMAIL)"
	@echo "Staging: $(STAGING)"
	$(DOCKER_COMPOSE) --profile production run --rm certbot sh -c "DOMAINS=$(DOMAIN) EMAIL=$(EMAIL) STAGING=$(STAGING) /scripts/init-letsencrypt.sh"

ssl-renew: ## Manually renew SSL certificates
	@echo "üîÑ Renewing SSL certificates..."
	$(DOCKER_COMPOSE) --profile production exec certbot /scripts/renew-certs.sh

ssl-status: ## Check SSL certificate status
	@echo "üìã SSL Certificate Status:"
	$(DOCKER_COMPOSE) --profile production exec certbot certbot certificates

ssl-test: ## Test SSL certificate renewal (dry run)
	@echo "üß™ Testing SSL certificate renewal..."
	$(DOCKER_COMPOSE) --profile production exec certbot certbot renew --dry-run

configure-domain: ## Configure nginx for specific domain (requires DOMAIN)
	@echo "üîß Configuring domain..."
	@if [ -z "$(DOMAIN)" ]; then echo "‚ùå Please specify DOMAIN=your-domain.com"; exit 1; fi
	$(DOCKER_COMPOSE) --profile production exec nginx sh -c "DOMAIN=$(DOMAIN) /scripts/configure-domain.sh $(DOMAIN)"
	$(DOCKER_COMPOSE) --profile production restart nginx

ssl-setup-complete: ## Complete SSL setup process (requires DOMAIN and EMAIL)
	@echo "üöÄ Complete SSL Setup Process"
	@echo "=============================="
	@if [ -z "$(DOMAIN)" ]; then echo "‚ùå Please specify DOMAIN=your-domain.com"; exit 1; fi
	@if [ -z "$(EMAIL)" ]; then echo "‚ùå Please specify EMAIL=your-email@example.com"; exit 1; fi
	$(MAKE) configure-domain DOMAIN=$(DOMAIN)
	$(MAKE) ssl-init DOMAIN=$(DOMAIN) EMAIL=$(EMAIL) STAGING=$(STAGING)
	@echo ""
	@echo "üéâ SSL setup complete!"
	@echo "üìù Next steps:"
	@echo "   1. Test your site: https://$(DOMAIN)"
	@echo "   2. Enable HTTPS redirect in nginx.conf"
	@echo "   3. Check certificate status: make ssl-status"

# SSL helper commands
ssl-remove: ## Remove all SSL certificates (DANGER: destructive operation)
	@echo "‚ö†Ô∏è  WARNING: This will remove ALL SSL certificates!"
	@read -p "Are you sure? (yes/no): " confirm; [ "$$confirm" = "yes" ] || exit 1
	$(DOCKER_COMPOSE) --profile production exec certbot rm -rf /etc/letsencrypt/live /etc/letsencrypt/archive /etc/letsencrypt/renewal
	@echo "üóëÔ∏è  SSL certificates removed"

ssl-logs: ## Show certbot logs
	@echo "üìã Certbot logs:"
	$(DOCKER_COMPOSE) --profile production logs certbot

# Heroku deployment commands
heroku-validate: ## Validate that the app builds correctly for Heroku
	@echo "üîç Validating Heroku deployment readiness..."
	@echo "üì¶ Testing Docker build process..."
	$(DOCKER_COMPOSE) build
	@echo "‚úÖ Docker build successful!"
	@echo "üìã Checking container functionality..."
	@$(DOCKER_COMPOSE) up -d
	@sleep 10
	@curl -f http://localhost:3000/api/health >/dev/null 2>&1 && echo "‚úÖ Health check passed" || echo "‚ùå Health check failed"
	@$(DOCKER_COMPOSE) down
	@echo "üéâ Ready for Heroku deployment!"

heroku-deploy: ## Deploy to Heroku (requires APP_NAME parameter)
	@echo "üöÄ Deploying to Heroku..."
	@if [ -z "$(APP_NAME)" ]; then echo "‚ùå Please specify APP_NAME=your-app-name"; exit 1; fi
	./scripts/deploy-heroku.sh $(APP_NAME)

heroku-logs: ## View Heroku logs (requires APP_NAME parameter)
	@if [ -z "$(APP_NAME)" ]; then echo "‚ùå Please specify APP_NAME=your-app-name"; exit 1; fi
	heroku logs --tail --app $(APP_NAME)

heroku-status: ## Check Heroku app status (requires APP_NAME parameter)
	@if [ -z "$(APP_NAME)" ]; then echo "‚ùå Please specify APP_NAME=your-app-name"; exit 1; fi
	@echo "üìä Heroku App Status:"
	heroku ps --app $(APP_NAME)
	@echo ""
	@echo "üîß Config Variables:"
	heroku config --app $(APP_NAME)

heroku-restart: ## Restart Heroku app (requires APP_NAME parameter)
	@if [ -z "$(APP_NAME)" ]; then echo "‚ùå Please specify APP_NAME=your-app-name"; exit 1; fi
	@echo "üîÑ Restarting Heroku app..."
	heroku restart --app $(APP_NAME)

heroku-open: ## Open Heroku app in browser (requires APP_NAME parameter)
	@if [ -z "$(APP_NAME)" ]; then echo "‚ùå Please specify APP_NAME=your-app-name"; exit 1; fi
	heroku open --app $(APP_NAME)

heroku-setup: ## Setup GitHub Actions secrets for Heroku deployment
	@echo "‚öôÔ∏è  Heroku Setup Guide"
	@echo "===================="
	@echo ""
	@echo "1. Create Heroku app:"
	@echo "   heroku create your-app-name --region eu"
	@echo ""
	@echo "2. Get API key:"
	@echo "   heroku auth:token"
	@echo ""
	@echo "3. Add GitHub secrets:"
	@echo "   - HEROKU_API_KEY (from step 2)"
	@echo "   - HEROKU_APP_NAME (your app name)"
	@echo "   - HEROKU_EMAIL (your Heroku email)"
	@echo ""
	@echo "4. Push to main branch to trigger deployment"
	@echo ""
	@echo "üìñ Full guide: docs/HEROKU_DEPLOY.md"

heroku-health: ## Check Heroku app health (requires APP_NAME parameter)
	@if [ -z "$(APP_NAME)" ]; then echo "‚ùå Please specify APP_NAME=your-app-name"; exit 1; fi
	@echo "üè• Checking app health..."
	@curl -f https://$(APP_NAME).herokuapp.com/api/health && echo "‚úÖ App is healthy!" || echo "‚ùå Health check failed"

# Custom domain management
domain-add: ## Add custom domain to Heroku app (requires APP_NAME and DOMAIN parameters)
	@if [ -z "$(APP_NAME)" ]; then echo "‚ùå Please specify APP_NAME=your-app-name"; exit 1; fi
	@if [ -z "$(DOMAIN)" ]; then echo "‚ùå Please specify DOMAIN=your-domain.com"; exit 1; fi
	@echo "üåê Adding custom domain $(DOMAIN) to $(APP_NAME)..."
	heroku domains:add $(DOMAIN) --app $(APP_NAME)
	@echo "üîê Enabling automatic SSL..."
	heroku certs:auto:enable --app $(APP_NAME)

domain-status: ## Check custom domain and SSL status (requires APP_NAME parameter)
	@if [ -z "$(APP_NAME)" ]; then echo "‚ùå Please specify APP_NAME=your-app-name"; exit 1; fi
	@echo "üåê Domain configuration:"
	heroku domains --app $(APP_NAME)
	@echo ""
	@echo "üîê SSL certificate status:"
	heroku certs:auto --app $(APP_NAME)

domain-test: ## Test custom domain connectivity (requires DOMAIN parameter)
	@if [ -z "$(DOMAIN)" ]; then echo "‚ùå Please specify DOMAIN=your-domain.com"; exit 1; fi
	@echo "üîç Testing DNS resolution for $(DOMAIN)..."
	@nslookup $(DOMAIN) || echo "‚ö†Ô∏è  DNS not yet propagated"
	@echo ""
	@echo "üåê Testing HTTP connectivity..."
	@curl -I http://$(DOMAIN) || echo "‚ö†Ô∏è  HTTP not yet available"
	@echo ""
	@echo "üîê Testing HTTPS connectivity..."
	@curl -I https://$(DOMAIN) || echo "‚ö†Ô∏è  HTTPS not yet available"

domain-health: ## Check health endpoint on custom domain (requires DOMAIN parameter)
	@if [ -z "$(DOMAIN)" ]; then echo "‚ùå Please specify DOMAIN=your-domain.com"; exit 1; fi
	@echo "üè• Testing health endpoint at https://$(DOMAIN)/api/health..."
	@curl -f https://$(DOMAIN)/api/health && echo "‚úÖ Custom domain is healthy!" || echo "‚ùå Custom domain health check failed"
